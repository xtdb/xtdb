---
title: XTDB Data Types
---

XTDB data types are implemented using Apache Arrow.

== Scalar Types

[cols="3,5,6,6"]
|===
|XTDB Type |Description |SQL Example |Clojure Example

|`BIGINT`
|64-bit Signed Integer
|`9223372036854775807`
|`9223372036854775807`

|`BOOLEAN`
|3-Value Boolean: true, false, or null
|`TRUE`
|`true`

|`DATE`
|Date Without Time
|`DATE '2007-06-29'`
|`#time/date "2007-06-29"`

|`DOUBLE`
|64-bit Floating Point Number
|`1.0`
|`1.0`

|`FLOAT`
|32-bit Floating Point Number
|`1.0`
|`1.0`

|`INTEGER`
|32-bit Signed Integer
|`2147483647`
|`2147483647`

|`INTERVAL`
|Day/Time Interval
|`INTERVAL '163 12'`
|TBD

|`INTERVAL`
|Year/Month Interval
|`INTERVAL '163-11'`
|TBD

|`PERIOD`
| <a pair of TIMESTAMPs>
|`PERIOD(DATE '1998-01-05', DATE '1998-01-12')`
|TBD

|`SMALLINT`
|16-bit Signed Integer
|`32767`
|`32767`

|`TIMESTAMP +
[WITHOUT +
TIMEZONE]`
|Timestamp without a Timezone offset
|`TIMESTAMP '16:00:00'`
|`#inst "2007-06-29T16:00:00Z"`

|`TIMESTAMP +
WITH +
TIMEZONE`
|Timestamp with a Timezone offset
|`TIMESTAMP '16:00:00+04:00'`
|TBD

|`TIME +
[WITHOUT +
TIMEZONE]`
|Time of day with nanosecond precision
|`TIME '22:15:04.1237'`
|TBD

|`UUID`
|Universally Unique Identifier
|`'97a392d5-5e3f-406f-9651-a828ee79b156'`
|`#uuid "97a392d5-5e3f-406f-9651-a828ee79b156"`

|`URI`
|Universal Resource Identifier
|`'https://xtdb.com'`
|TBD

|`VARBINARY`
|Variable-Length Binary String (Byte Array)
|`0x41424344`
|TBD

|`VARCHAR`
|Variable-Length String with UTF8 character encoding
|`'Hello'`
|`"Hello"`

|`KEYWORD`
|EDN Keyword
|`-- TBD`
|`:keyword`

|`DURATION`
| Duration of time
|TBD
|`#time/duration "PT1H3M5S"`

|===

////
Undocumented / Unsupported:

* Keyword / :keyword
* TinyInt / :i8 -- the SQL Spec seems to have no direct support for TinyInt / Byte
* Date/Time types with (seemingly?) no spec equivalent:
** Instant
** ZonedDateTime
** OffsetDateTime
** LocalDateTime
** Duration
** LocalDate

Unsupported, but exists in spec:
|`TIME WITH TIME ZONE`
|`?`
|Time of day with nanosecond precision
|`TIME WITH TIME ZONE '22:15:04.1237'`

////

== Collection Types

XTDB supports arbitrarily nested data.

[cols="3,5,6,6"]
|===
|XTDB Type |Description |SQL Example |Clojure Example

|`ARRAY`
|Array/List/Vector of Values
|`[1, 2, 3]`
|`[1 2 3]`

|`OBJECT`
|Object/Struct/Map of key-value pairs
|`{'name':'Lucy', 'age':'38'}`
|`{:name 'Lucy', :age '38'}`

|`SET`
|Set of distinct, unordered values
|TBD
|`#{"Lucy" "38"}`

|===

== Null/Absent

XTDB differentiates between an explicitly provided 'null' value and the absence of a value - for example, none of these three documents are not considered equivalent:

[source,json]
----
{ "xt$id" : "steve", "middleName" : null }
{ "xt$id" : "steve", "middleName" : null } // i.e. null != null
{ "xt$id" : "steve" } // i.e. null != absent
----

XTDB's expression engine handles null values using https://en.wikipedia.org/wiki/Three-valued_logic[3-valued logic], in keeping with the SQL standard - for example:

* By default, whenever a function is passed any argument that is null, the whole function returns null - e.g. `4 + NULL` returns null.
** The exceptions are well-defined - e.g. `IS_NULL(NULL)` is obviously true.
** Null values are not equal to each other - e.g. two tables with a join condition of `left.a = right.b` will not yield any rows where either `left.a` or `right.b` is null.
* When aggregating (e.g. `SELECT t.a, COUNT(t.b) FROM table t GROUP BY t.a`), all values with null `t.a` are grouped in the same bucket (again, in keeping with the SQL standard).

Absence is handled similarly to null but with some subtle differences:

* By default, whenever a function is passed any argument that is missing in the input document, the whole function returns null - e.g. `4 + a` returns null for rows missing `a`.
* Absent values _are_ equal to each other - e.g. if you join using `left.a = right.b`, row pairs where neither table has a value defined for the given column will join.
* When aggregating, rows with absent grouping values are grouped in the same bucket as the nulls.
* When ordering by 'nulls first' or 'nulls last', we use `null < absent < any other value` and `any other value < absent < null` respectively.
