= Full-text Lucene search

Full-text search module for Crux making use of https://lucene.apache.org/[Apache
Lucene].

`crux-lucene` runs in-process as part of the Crux node as a Crux module.
The Lucene index is kept up-to-date asynchronously by hooking into the underlying Crux transactions processing on a node as a "secondary index".

[WARNING]
This module is in alpha and likely to change.
In particular, we might rationalize/combine the different query functions available (see https://github.com/juxt/crux/issues/1318).

== Setup

First, add the `crux-lucene` dependency to your project:

[tabs]
====
deps.edn::
+
[source,clojure, subs=attributes+]
----
pro.juxt.crux/crux-lucene {:mvn/version "{crux_version}"}
----

pom.xml::
+
[source,xml, subs=attributes+]
----
<dependency>
    <groupId>pro.juxt.crux</groupId>
    <artifactId>crux-lucene</artifactId>
    <version>{crux_version}</version>
</dependency>
----
====


Add the following to your node configuration:

[tabs]
====
JSON::
+
[source,json]
----
{
  "crux.lucene/lucene-store": {
    // omit `"db-dir"` to start an in-memory-only Lucene store.
    "db-dir": "lucene",
  }
}
----

Clojure::
+
[source,clojure]
----
{...
 ; omit `:db-dir` to start an in-memory-only Lucene store.
 :crux.lucene/lucene-store {:db-dir "lucene-dir"}}
----

EDN::
+
[source,clojure]
----
{...
 ; omit `:db-dir` to start an in-memory-only Lucene store.
 :crux.lucene/lucene-store {:db-dir "lucene-dir"}}
----
====

== Indexing

All top-level text fields in a document are automatically indexed.

== Datalog Querying

You can use the built-in `text-search` function within in your Datalog queries:

[source,clojure]
----
{:find '[?e]
 :where '[[(text-search :name "Ivan") [[?e]]]
 [?e :crux.db/id]]}
----

The destructuring available is `entity-id`, `matched-value` and `score`.
For example, to return the complete search results tuples:

[source,clojure]
----
{:find '[?e ?v ?s]
 :where '[[(text-search :name "Ivan") [[?e ?v ?s]]]
 [?e :crux.db/id]]}
----

In the above example, `?e` is the entity ID of the matched search result.
`?v` is the matched value and `?s` is the matched score.

You can use standard Lucene fuzzy textual search capabilities:

[source,clojure]
----
{:find '[?e]
 :where '[[(text-search :name "Iva*") [[?e]]]
 [?e :crux.db/id]]}
----

This will return all entities with a `:name` attribute that starts with "Iva". Note that large result sets will be fully realized and there is currently no means to specify a limit.

This module does not support "leading wildcard" searches, e.g. "*van", even though Lucene is technically capable of performing these queries.

All query functions implemented in `crux-lucene` pass your query string directly to Lucene's `QueryParser.parse` using the `StandardAnalyzer`, without any escaping or other modifications.
See the Lucene documentation for more information.

It's possible to supply var bindings to use in `text-search`:

[source,clojure]
----
(c/q db '{:find [?v]
          :in [input]
          :where [[(text-search :name input) [[?e ?v]]]]}
     "Ivan")
----

== Wildcard Attributes

There is a wildcard search function, where you can search across all attributes:

[source,clojure]
----
{:find '[?e ?v ?a ?s]
 :where '[[(wildcard-text-search "Iva*") [[?e ?v ?a ?s]]]
 [?e :crux.db/id]]}
----

This will return all entities that have an attribute with a value that matches "Iva".
The destructured binding also contains `a` which is the matched attribute.

== Multi-field searches

There is an entirely different search-function available for multi-field searches using Lucene in Crux: `lucene-text-search`:

[source,clojure]
----
{:find '[?e]
 :where '[[(lucene-text-search "firstname:James OR surname:preston") [[?e]]]]}
----

This `lucene-text-search` takes a Lucene query string.

[WARNING]
If you use `lucene-text-search`, you cannot use the search functions listed above - `wildcard-text-search` and `text-search`.
This is because the way we index documents into Lucene is different.

[NOTE]
In the normal case for `text-search` and `wildcard-text-search`, we index each A/V pair in a Crux document as individual documents in Lucene.
This allows for a large degree of structural sharing, which will help in the case where there is a lot historical data in Crux.
This is targeted to ease the disk-space taken up by Lucene, but also for query efficiency reasons.

[NOTE]
`lucene-text-search` indexs a single document per document-version in Crux.
The downside of this is structural sharing impacting disk space, but the upside is taking advantage of more of the Lucene query language capability, and to perform queries taking into account multiple fields.

To enable `lucene-text-search`, you must configure the Lucene Indexer, such like:

[source,clojure]
----
{...
 :crux.lucene/lucene-store {:indexer 'crux.lucene.multi-field/->indexer}}
----

=== Bindings

It's possible to supply var bindings also, that are wired in using `format` when the vars are bound.

[source,clojure]
----
{:find [?e]
 :in [?surname ?firstname]
 :where [[(lucene-text-search "surname: %s AND firstname: %s" ?surname ?firstname) [[?e]]]]}
----

=== String Escaping

You can escape your input strings when constructing Lucene query strings by calling `org.apache.lucene.queryparser.classic.QueryParser/escape`. For example, this method would transform `"|&hello&|"` to `"\\|\\&hello\\&\\|"`.

This is helpful to mitigate against injection attacks and other errors.

== Searching outside of Datalog

The more direct `crux.lucene/search` function is available to lazily return results, without the temporal filtering or other constraints of using Lucene via the `q` API.

The function accepts 3 parameters (`node`, `query` and `opts`) and returns an iterable cursor of results that must be closed.

The `query` parameter can be either a Lucene query string or an `org.apache.lucene.search.Query` object.

The `opts` parameter accepts a map with a single `:default-field` entry. The value of this entry will be supplied to the Lucene `QueryParser` in the cases where the supplied `query` parameter is a Lucene query string.

[source,clojure]
----
(with-open [search-results (crux.lucene/search node "Ivan")]
  (into [] (iterator-seq search-results)))
----

== Checkpointing Lucene

For more details about checkpointing in Crux, see the xref:checkpointing.adoc[main Checkpointing docs].

You can set up checkpointing on your Lucene store too, in addition to the main Crux query indices.
This means that a new node starting up will be able to download a checkpoint of a reasonably recent Lucene store from a central location rather than having to replay all of the transactions.

The parameters are the same as for the main Crux query indices, except applied to your Lucene store component:

[tabs]
====
JSON::
+
[source,json]
----
{
  "crux.lucene/index-store": {
    "db-dir": "lucene-dir",
    "checkpointer": {
      "crux/module": "crux.checkpoint/->checkpointer",
      "store": {
        "crux/module": "crux.checkpoint/->filesystem-checkpoint-store",
        "path": "/path/to/cp-store"
      },
      "approx-frequency": "PT6H"
    }
  },
  ...
}
----

Clojure::
+
[source,clojure]
----
{:crux.lucene/lucene-store {:db-dir "lucene-dir"
                            :checkpointer {:crux/module 'crux.checkpoint/->checkpointer
                                           :store {:crux/module 'crux.checkpoint/->filesystem-checkpoint-store
                                                   :path "/path/to/cp-store"}
                                           :approx-frequency (Duration/ofHours 6)}}}
 ...}
----

EDN::
+
[source,clojure]
----
{:crux.lucene/lucene-store {:db-dir "lucene-dir"
                            :checkpointer {:crux/module crux.checkpoint/->checkpointer
                                           :store {:crux/module crux.checkpoint/->filesystem-checkpoint-store
                                                   :path "/path/to/cp-store"}
                                           :approx-frequency "PT6H"}}}
 ...}
----
====
