-- trie-cat.allium
--
-- The trie catalog: per-table inventory of immutable trie snapshots.
--
-- Tries are added by block flushes (see db.allium) and compaction (see compaction.allium).
-- Tries are read by the scan operator for query execution.
-- Tries are garbage-collected by gc.allium once superseded by compaction output.
--
-- See: trie/TrieCatalog.kt, log/proto/log.proto (TrieDetails, TrieState)

------------------------------------------------------------
-- Values
------------------------------------------------------------

value TableRef {
    -- See: api/.../table/TableRef.kt
    db_name: String
    schema_name: String
    table_name: String
}

value TrieDetails {
    -- Per-trie metadata written to the log on block flush or compaction.
    -- See: log/proto/log.proto (TrieDetails)
    table: TableRef
    trie_key: TrieKey
    data_file_size: Long
    trie_metadata: TrieMetadata
    trie_state: TrieState
    garbage_as_of: Instant?
}

value TrieMetadata {
    -- See: log/proto/log.proto (TrieMetadata)
    temporal_metadata: TemporalMetadata
    row_count: Long
    iid_bloom: Bytes
}

value TemporalMetadata {
    -- See: log/proto/log.proto (TemporalMetadata)
    min_valid_from: Instant
    max_valid_from: Instant
    min_valid_to: Instant
    max_valid_to: Instant
    min_system_from: Instant
    max_system_from: Instant
}

value TrieKey {
    level: Long
    recency: LocalDate?  -- null = current (∞); date = historical (week ending Monday 0000Z)
    part: Bytes?         -- present at L2+; IID prefix path segments
    block_index: Long

    -- Derived
    is_current: recency == null

    -- Serialised as a string using lex hex encoding for levels and blocks.
    -- Lex hex: first digit is the length of the hex string minus one; remainder is the hex string.
    -- e.g. b134 is block 0x34 (decimal 52).
    -- Examples:
    --   l00-rc-b00         level 0, current, block 0
    --   l01-r20200106-b00  level 1, historical, week ending 2020-01-06
    --   l02-rc-p0-b00      level 2, current, IID partition 0, block 0
}

------------------------------------------------------------
-- Trie State Lifecycle
------------------------------------------------------------

value TrieState {
    -- Every trie has a state: nascent → live → garbage.
    -- See: log/proto/log.proto (TrieState)
    --
    -- nascent: the trie has been uploaded but its job group is not yet complete.
    --   A nascent trie is visible to the compactor (so it doesn't re-do the work)
    --   but is not yet used for queries.
    --
    -- live: the trie is complete and available for query execution.
    --   A trie becomes live when the last output of its job group is uploaded.
    --   At that point, the input tries of the job transition to garbage.
    --
    -- garbage: the trie has been fully superseded by compaction output.
    --   The garbage collector deletes the data and meta files from the object store,
    --   then removes the trie from the catalog.

    state: nascent | live | garbage
}

-- The LSM tree is split into current (C) and historical (H) sides based on the recency of events.
--
-- Current files have recency = ∞ (events whose valid-time range has not been superseded).
-- Historical files have finite recency, partitioned into weekly buckets rolling over every Monday at 0000Z.
--
-- The split exploits the Lindy effect: recently-written rows are more likely to be superseded quickly.

value TrieLevel = Long

------------------------------------------------------------
-- Context
------------------------------------------------------------

context {
    trie_catalog: TrieCatalog
}

------------------------------------------------------------
-- Entity
------------------------------------------------------------

-- Behaviourally-relevant fields only; see TrieCatalog.kt for full interface.

entity TrieCatalog {
    -- See: trie/TrieCatalog.kt, trie_catalog.clj
    --
    -- Per-table catalog, keyed by shard = (level, recency, part).
    -- Each shard holds three ordered lists (by block_index descending): live, nascent, garbage.
    -- Also tracks max_block_index per shard for staleness detection.
    --
    -- addTries(tries, as_of): register new tries, transitioning superseded inputs to garbage.
    -- refresh: rebuild the entire catalog from block metadata in the object store.
    --   Used by read-only followers after a new block appears.
    -- deleteTries(tries): remove garbage entries from the catalog after file deletion.
    tries: Map<TableRef, Map<Shard, ShardState>>
}

value Shard = (level: Long, recency: LocalDate?, part: List<Long>)

value ShardState {
    live: List<TrieDetails>       -- ordered by block_index descending
    nascent: List<TrieDetails>    -- ordered by block_index descending
    garbage: List<TrieDetails>    -- ordered by block_index descending
    max_block_index: Long
}

------------------------------------------------------------
-- Config
------------------------------------------------------------

config {
    branch_factor: Integer = 4
    file_size_target: Long = 104857600   -- 100 MB
}

------------------------------------------------------------
-- Rules
------------------------------------------------------------

rule TriesAdded {
    -- Called by db.allium (block flush, ProcessTriesAddedMessage) and compaction.allium.
    when: TriesAdded(tries, as_of)

    ensures:
        for each trie in tries:
            trie_catalog.applyTrieNotification(trie, as_of)
}

rule ApplyTrieNotification {
    -- Idempotent: stale notifications (already-seen block indices) are skipped.
    -- Messages have a total ordering within their shard, so we only ever prepend.
    -- See: trie_catalog.clj (apply-trie-notification, stale-msg?)
    when: ApplyTrieNotification(trie, as_of)

    let shard = (trie.level, trie.recency, trie.part)
    let shard_state = trie_catalog.tries[trie.table][shard]

    requires: not stale(shard_state, trie.block_index)
    -- stale iff shard_state.max_block_index >= trie.block_index

    ensures: InsertTrie(trie, as_of)
}

------------------------------------------------------------
-- Rules: InsertTrie
--
-- The insertion strategy varies by level and recency.
-- Key concepts:
--   Levelled: the new trie supersedes partial (< file_size_target) predecessors
--     in the same shard. Used for L1C, L2H.
--   Tiered: the new trie is added alongside existing tries without superseding.
--     Used for L1H, L2+C, L3+H.
--   Nascent: the trie is not yet queryable; it becomes live when a completion
--     condition is met (L1C arrives for L1H; all partition siblings arrive for L2+).
--
-- See: trie_catalog.clj (insert-trie)
------------------------------------------------------------

rule InsertTrie_L0 {
    -- L0 files are always live immediately.
    when: InsertTrie(trie, as_of) where trie.level == 0

    ensures:
        add trie as :live to shard [0, trie.recency, trie.part]
}

rule InsertTrie_L1H {
    -- L1H files are nascent until the corresponding L1C file arrives.
    -- When the L1C with the same (or later) block_index appears, it marks them live.
    -- See: trie_catalog.clj (insert-trie, level 1 with recency)
    when: InsertTrie(trie, as_of) where trie.level == 1 and trie.recency != null

    let l1c_shard = trie_catalog.tries[trie.table][(1, null, trie.part)]
    let l1c_latest = l1c_shard.live.first   -- highest block_index

    let state =
        if l1c_latest != null and l1c_latest.block_index >= trie.block_index:
            :live    -- L1C already exists that covers this block
        else:
            :nascent -- wait for L1C

    ensures:
        add trie as state to shard [1, trie.recency, trie.part]
        -- Track recency so that when L1C arrives, it can find these L1H files.
        record l1h_recency(trie.block_index, trie.recency)
}

rule InsertTrie_L1C {
    -- L1C is levelled: supersedes partial (< file_size_target) L1C files.
    -- Also supersedes L0 files and marks pending L1H files as live.
    -- See: trie_catalog.clj (insert-trie, level 1 without recency)
    when: InsertTrie(trie, as_of) where trie.level == 1 and trie.recency == null

    ensures:
        -- 1. Mark any L1H files for this block_index as live.
        for each recency in l1h_recencies(trie.block_index):
            mark_block_index_live(shard [1, recency, []], trie.block_index)

        -- 2. Supersede partial L1C files (levelled insertion).
        supersede_partial([1, null, []], trie, as_of)
        add trie as :live to shard [1, null, []]

        -- 3. Supersede L0 files up to this block_index.
        supersede_by_block_index([0, null, []], trie.block_index, as_of)
}

rule InsertTrie_L2H {
    -- L2H is levelled: supersedes partial L2H files and the L1H inputs.
    -- See: trie_catalog.clj (insert-trie, level 2 with recency)
    when: InsertTrie(trie, as_of) where trie.level == 2 and trie.recency != null

    ensures:
        -- Supersede partial L2H files (levelled insertion).
        supersede_partial([2, trie.recency, trie.part], trie, as_of)
        add trie as :live to shard [2, trie.recency, trie.part]

        -- Supersede L1H inputs up to this block_index.
        supersede_by_block_index([1, trie.recency, []], trie.block_index, as_of)
}

rule InsertTrie_General {
    -- L2+C, L3+H: tiered with partition-group completion.
    -- The trie starts as nascent. When all siblings in the partition group
    -- (branch_factor siblings sharing the same parent part prefix) are present,
    -- all become live and the prior level is superseded.
    -- See: trie_catalog.clj (insert-trie, default case)
    when: InsertTrie(trie, as_of)
        where not (trie.level == 0
                   or (trie.level == 1)
                   or (trie.level == 2 and trie.recency != null))

    ensures:
        add trie as :nascent to shard [trie.level, trie.recency, trie.part]

        if completed_part_group(trie):
            -- All branch_factor siblings exist for this block_index.
            mark_part_group_live(trie)

            -- Supersede prior level: parent shard at (level - 1, recency, pop(part)).
            let parent_part = if trie.part.non_empty: trie.part.pop else trie.part
            supersede_by_block_index(
                [trie.level - 1, trie.recency, parent_part],
                trie.block_index, as_of
            )
}

------------------------------------------------------------
-- Rules: Supersession helpers
------------------------------------------------------------

rule supersede_partial {
    -- Levelled supersession: mark live tries as garbage if they are partial
    -- (data_file_size < file_size_target) and have block_index <= the new trie's.
    -- See: trie_catalog.clj (supersede-partial-tries)
    when: supersede_partial(shard, new_trie, as_of)

    ensures:
        for each live_trie in shard.live
            where live_trie.data_file_size < config.file_size_target
              and live_trie.block_index <= new_trie.block_index:
            transition live_trie to :garbage with garbage_as_of = as_of
}

rule supersede_by_block_index {
    -- Unconditional supersession: mark all live tries as garbage
    -- if their block_index <= the given block_index.
    -- See: trie_catalog.clj (supersede-by-block-idx)
    when: supersede_by_block_index(shard, block_index, as_of)

    ensures:
        for each live_trie in shard.live
            where live_trie.block_index <= block_index:
            transition live_trie to :garbage with garbage_as_of = as_of
}

rule completed_part_group {
    -- True when all branch_factor siblings at (level, recency, parent_part ++ [0..3])
    -- have max_block_index >= the new trie's block_index.
    -- See: trie_catalog.clj (completed-part-group?, sibling-tries)
    when: completed_part_group(trie) -> Boolean

    let parent_part = trie.part.pop
    ensures:
        for each p in 0..(config.branch_factor - 1):
            let sibling_shard = trie_catalog.tries[trie.table][(trie.level, trie.recency, parent_part ++ [p])]
            sibling_shard.max_block_index >= trie.block_index
}

rule mark_part_group_live {
    -- Transition all nascent tries at the given block_index across the partition group to live.
    -- See: trie_catalog.clj (mark-part-group-live, mark-block-idx-live)
    when: mark_part_group_live(trie)

    let parent_part = trie.part.pop
    ensures:
        for each p in 0..(config.branch_factor - 1):
            let shard = [trie.level, trie.recency, parent_part ++ [p]]
            mark_block_index_live(shard, trie.block_index)
}

rule mark_block_index_live {
    -- Find a nascent trie at the given block_index and transition it to live.
    -- See: trie_catalog.clj (mark-block-idx-live)
    when: mark_block_index_live(shard, block_index)

    let nascent_trie = shard.nascent.find(t => t.block_index == block_index)

    ensures:
        if nascent_trie != null:
            transition nascent_trie from :nascent to :live
}

------------------------------------------------------------
-- Rules: Refresh and Delete
------------------------------------------------------------

rule FollowerRefreshes {
    -- Read-only nodes refresh the catalog from the object store after a block appears.
    when: FollowerRefreshRequested()

    ensures:
        trie_catalog.refresh()
}

------------------------------------------------------------
-- Surfaces
------------------------------------------------------------

surface ScanOperatorAccess {
    -- The scan operator reads the trie catalog to determine which files to read for a query.
    -- Only live tries are used; nascent tries are excluded from query execution.
    -- See: operator/scan.clj (current-tries)

    context table: TableRef

    exposes:
        trie_catalog.currentTries(table)    -- live tries only; see operator/scan.clj
        trie_catalog.getPartitions(table)
}

