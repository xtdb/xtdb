apiVersion: v1
kind: ConfigMap
metadata:
  name: xtdb-env-config
  namespace: {{ .Release.Namespace }}
data:
  KAFKA_BOOTSTRAP_SERVERS: {{ .Values.xtdbConfig.kafkaBootstrapServers | quote }}
  XTDB_LOG_TOPIC: {{ .Values.xtdbConfig.logTopic | quote }}
  JDK_JAVA_OPTIONS: {{ .Values.xtdbConfig.jdkOptions | quote }}
  XTDB_LOGGING_LEVEL: {{ .Values.xtdbConfig.loggingLevel | quote }}
  {{- with .Values.providerConfig.env }}
  {{- range $key, $val := . }}
  {{ $key }}: {{ $val | quote }}
  {{- end }}
  {{- end }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: dump-upload-scripts
  namespace: {{ .Release.Namespace }}
data:
  upload-dumps.sh: |
    #!/bin/bash
    # NOTE: This sidecar must always exit 0 to avoid failing the Job
    # Errors are logged but don't affect exit code
    set -uo pipefail
    trap 'exit 0' EXIT TERM INT

    DUMP_DIR=/dumps
    PREFIX="dumps/${XTDB_NODE_ID:-unknown}/$(date +%Y-%m-%dT%H-%M-%S)"

    echo "Installing inotify-tools and procps..."
    if command -v apk &>/dev/null; then
      apk add --no-cache inotify-tools procps >/dev/null 2>&1
    elif command -v tdnf &>/dev/null; then
      tdnf install -y inotify-tools procps-ng >/dev/null 2>&1
    else
      apt-get update -qq && apt-get install -y -qq inotify-tools procps >/dev/null 2>&1
    fi

    # Azure workload identity login
    if [[ -n "${AZURE_FEDERATED_TOKEN_FILE:-}" ]]; then
      echo "Logging in with Azure workload identity..."
      az login --federated-token "$(cat "$AZURE_FEDERATED_TOKEN_FILE")" \
        --service-principal \
        -u "$AZURE_CLIENT_ID" \
        -t "$AZURE_TENANT_ID" \
        --output none
    elif [[ -n "${AZURE_CLIENT_ID:-}" ]]; then
      echo "Logging in with Azure managed identity..."
      az login --identity --username "$AZURE_CLIENT_ID" --output none
    fi

    upload_file() {
      local file=$1
      echo "Uploading $file to $PREFIX/$file..."
      az storage blob upload \
        --account-name "$AZURE_STORAGE_ACCOUNT" \
        --container-name "${AZURE_DUMPS_CONTAINER:-$AZURE_STORAGE_CONTAINER}" \
        --name "$PREFIX/$file" \
        --file "$DUMP_DIR/$file" \
        --auth-mode login \
        --overwrite
      echo "Uploaded: $PREFIX/$file"
    }

    echo "Watching $DUMP_DIR for heap dumps..."

    # Start inotifywait in background so we can kill it later
    inotifywait -m -e close_write --format '%f' "$DUMP_DIR" 2>/dev/null | while read -r file; do
      if [[ "$file" == *.hprof ]]; then
        upload_file "$file"
      fi
    done &
    WATCH_PID=$!

    # Wait for main container (java process) to exit
    while pgrep -x java >/dev/null 2>&1; do
      sleep 5
    done

    echo "Main container exited, waiting 10s for any final uploads..."
    sleep 10

    # Upload any dumps that might have been missed
    for f in "$DUMP_DIR"/*.hprof; do
      [[ -f "$f" ]] && upload_file "$(basename "$f")"
    done

    # Fallback: trigger cleanup workflow if main container didn't (e.g. OOM kill)
    if [ ! -f "$DUMP_DIR/.cleanup-triggered" ] && [ -n "${GITHUB_PAT:-}" ]; then
      echo "Main container did not trigger cleanup. Triggering from sidecar as fallback..."
      GITHUB_REPO="${GITHUB_REPOSITORY:-xtdb/xtdb}"
      WORKFLOW_URL="https://api.github.com/repos/${GITHUB_REPO}/actions/workflows/nightly-benchmark-cleanup.yml/dispatches"
      REF="${GIT_BRANCH:-main}"

      INPUTS="{\"benchType\":\"${BENCH_TYPE}\",\"status\":\"failure\",\"nodeId\":\"${XTDB_NODE_ID}\"}"
      if [ "${RUN_QUEUE:-}" = "true" ]; then
        INPUTS="{\"benchType\":\"${BENCH_TYPE}\",\"status\":\"failure\",\"nodeId\":\"${XTDB_NODE_ID}\",\"runQueue\":\"true\"}"
      fi

      curl -s -X POST \
        -H "Accept: application/vnd.github+json" \
        -H "Authorization: Bearer ${GITHUB_PAT}" \
        "${WORKFLOW_URL}" \
        -d "{\"ref\":\"${REF}\",\"inputs\":${INPUTS}}" \
        && echo "Cleanup workflow triggered from sidecar" \
        || echo "Failed to trigger cleanup from sidecar (non-fatal)"
    elif [ -f "$DUMP_DIR/.cleanup-triggered" ]; then
      echo "Cleanup already triggered by main container."
    fi

    echo "Sidecar exiting."
    kill $WATCH_PID 2>/dev/null || true
