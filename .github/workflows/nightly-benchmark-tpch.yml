name: Nightly Benchmark TPC-H
run-name: "TPC-H (SF: ${{ inputs.scale_factor || '1.0' }})"

on:
  workflow_dispatch:
    inputs:
      scale_factor:
        description: 'Scale Factor'
        required: false
        default: '1.0'
        type: string
  schedule:
    - cron: '0 0 * * *'  # Run daily at midnight UTC

permissions:
  id-token: write
  contents: read
  actions: write

concurrency:
  group: nightly-benchmark-tpch
  cancel-in-progress: false

jobs:
  benchmark:
    name: "TPC-H (SF: ${{ inputs.scale_factor || '1.0' }})"
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'schedule' || github.repository == 'xtdb/xtdb' }}
    timeout-minutes: 90
    env:
      SCALE_FACTOR: ${{ inputs.scale_factor || '1.0' }}
      GRAFANA_ADMIN_PASSWORD: ${{ secrets.BENCHMARK_GRAFANA_ADMIN_PASSWORD }}

    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5

      - name: Azure CLI Login
        uses: azure/login@a457da9ea143d694b1b9c7c869ebb04ebe844ef5 # v2
        with:
          client-id: ${{ secrets.BENCHMARK_AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.BENCHMARK_AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.BENCHMARK_AZURE_SUBSCRIPTION_ID }}

      - name: Acquire Kubernetes Configuration
        run: |
          az aks get-credentials --resource-group cloud-benchmark-resources --name xtdb-bench-cluster

      - name: Check Existing Deployment
        id: check-deployment
        continue-on-error: true
        run: |
          # exit 0 if exists, non-zero if not
          helm status xtdb-benchmark -n cloud-benchmark >/dev/null 2>&1

      - name: Inspect Existing Deployment
        if: steps.check-deployment.outcome == 'success'
        id: inspect-deployment
        run: |
          set -euo pipefail

          jobs_json=$(kubectl get jobs -n cloud-benchmark -o json 2>/dev/null || echo '{"items":[]}')
          job_count=$(echo "$jobs_json" | jq '.items | length')

          running_jobs_json=$(echo "$jobs_json" | jq -c '[.items[] | select((.status.active // 0) > 0) | .metadata.name]')
          failed_jobs_json=$(echo "$jobs_json" | jq -c '[.items[] | select((.status.failed // 0) > 0 or ((.status.conditions // []) | map(select(.type == "Failed" and .status == "True")) | length) > 0) | .metadata.name]')
          succeeded_jobs_json=$(echo "$jobs_json" | jq -c '[.items[] | select((.status.active // 0) == 0 and ((.status.succeeded // 0) > 0 or ((.status.conditions // []) | map(select(.type == "Complete" and .status == "True")) | length) > 0)) | .metadata.name]')
          terminal_jobs_json=$(echo "$jobs_json" | jq -c '[.items[] | select((.status.active // 0) == 0 and (((.status.succeeded // 0) > 0) or ((.status.failed // 0) > 0) or ((.status.conditions // []) | map(select((.type == "Complete" and .status == "True") or (.type == "Failed" and .status == "True"))) | length) > 0)) | .metadata.name]')
          pending_jobs_json=$(echo "$jobs_json" | jq -c '[.items[] | select((.status.active // 0) == 0 and ((.status.succeeded // 0) == 0) and ((.status.failed // 0) == 0) and ((.status.conditions // []) | length) == 0) | .metadata.name]')

          running_count=$(echo "$running_jobs_json" | jq 'length')
          failed_count=$(echo "$failed_jobs_json" | jq 'length')
          success_count=$(echo "$succeeded_jobs_json" | jq 'length')
          terminal_count=$(echo "$terminal_jobs_json" | jq 'length')
          pending_count=$(echo "$pending_jobs_json" | jq 'length')



          if [ "$job_count" -eq 0 ]; then
            DEPLOYMENT_STATUS="completed"
          elif [ "$running_count" -gt 0 ]; then
            DEPLOYMENT_STATUS="in_progress"
          elif [ "$failed_count" -gt 0 ]; then
            DEPLOYMENT_STATUS="failed"
          elif [ "$success_count" -gt 0 ] || [ "$terminal_count" -gt 0 ]; then
            DEPLOYMENT_STATUS="completed"
          elif [ "$pending_count" -gt 0 ]; then
            DEPLOYMENT_STATUS="in_progress"
          else
            DEPLOYMENT_STATUS="in_progress"
          fi

          echo "Existing deployment status: ${DEPLOYMENT_STATUS}"
          echo "Jobs discovered: $(echo "$jobs_json" | jq -r '[.items[].metadata.name] | join(", ")')"
          echo "Running jobs: $(echo "$running_jobs_json" | jq -r 'join(", ")')"
          echo "Failed jobs: $(echo "$failed_jobs_json" | jq -r 'join(", ")')"
          echo "Succeeded jobs: $(echo "$succeeded_jobs_json" | jq -r 'join(", ")')"
          echo "Terminal jobs: $(echo "$terminal_jobs_json" | jq -r 'join(", ")')"

          echo "deployment_status=${DEPLOYMENT_STATUS}" >> "$GITHUB_OUTPUT"
          echo "job_names=$(echo "$jobs_json" | jq -c '[.items[].metadata.name]')" >> "$GITHUB_OUTPUT"
          echo "terminal_job_names=${terminal_jobs_json}" >> "$GITHUB_OUTPUT"
          echo "failed_job_names=${failed_jobs_json}" >> "$GITHUB_OUTPUT"
          echo "succeeded_job_names=${succeeded_jobs_json}" >> "$GITHUB_OUTPUT"

      - name: Cleanup Existing Deployment
        if: steps.inspect-deployment.outputs.deployment_status == 'completed' || steps.inspect-deployment.outputs.deployment_status == 'failed'
        run: |
          set -euo pipefail
          echo "Previous benchmark finished with status: ${{ steps.inspect-deployment.outputs.deployment_status }}. Cleaning up release before proceeding."
          ./modules/bench/cloud/clear-bench.sh azure

      - name: Cancel workflow (existing deployment)
        if: steps.check-deployment.outcome == 'success' && steps.inspect-deployment.outputs.deployment_status == 'in_progress'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            core.notice('Existing deployment found and still in progress. Cancelling this workflow run to avoid overlap.');
            await github.rest.actions.cancelWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId,
            });

      - name: Stop job after cancellation
        if: steps.check-deployment.outcome == 'success' && steps.inspect-deployment.outputs.deployment_status == 'in_progress'
        run: |
          echo "Workflow cancellation requested due to existing deployment. Stopping job."
          exit 0

      - name: Install Monitoring Stack
        if: steps.check-deployment.outcome != 'success' || steps.inspect-deployment.outputs.deployment_status != 'in_progress'
        continue-on-error: true
        run: |
          bash ./modules/bench/cloud/monitoring/install-monitoring.sh

      - name: Create Bench Secret (GITHUB_PAT)
        if: steps.check-deployment.outcome != 'success' || steps.inspect-deployment.outputs.deployment_status != 'in_progress'
        run: |
          set -euo pipefail
          kubectl -n cloud-benchmark create secret generic xtdb-bench-secrets \
            --from-literal=GITHUB_PAT="${{ secrets.BENCHMARK_GITHUB_PAT }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Record Deployment Start
        if: steps.check-deployment.outcome != 'success' || steps.inspect-deployment.outputs.deployment_status != 'in_progress'
        run: echo "DEPLOY_START=$(date -u +%s)" >> "$GITHUB_ENV"

      - name: Run Benchmark
        if: steps.check-deployment.outcome != 'success' || steps.inspect-deployment.outputs.deployment_status != 'in_progress'
        run: |
          helm dependency update ./modules/bench/cloud/helm
          helm upgrade --install "xtdb-benchmark" ./modules/bench/cloud/helm \
            --namespace "cloud-benchmark" \
            --create-namespace \
            -f ./modules/bench/cloud/azure/values.yaml \
            --set "benchType=tpch" \
            --set "tpch.scaleFactor=${{ env.SCALE_FACTOR }}" \
            --set "providerConfig.existingSecret=xtdb-bench-secrets" \
            --set "providerConfig.env.AZURE_USER_MANAGED_IDENTITY_CLIENT_ID=${{ secrets.BENCHMARK_AZURE_USER_MANAGED_IDENTITY_CLIENT_ID }}" \
            --set "providerConfig.serviceAccountAnnotations.azure\.workload\.identity/client-id=${{ secrets.BENCHMARK_AZURE_USER_MANAGED_IDENTITY_CLIENT_ID }}"

      - name: Remove Monitoring Stack on Failure
        if: failure() && (steps.check-deployment.outcome != 'success' || steps.inspect-deployment.outputs.deployment_status != 'in_progress')
        run: |
          if helm status monitoring -n monitoring >/dev/null 2>&1; then
            echo "Uninstalling monitoring stack due to benchmark failure..."
            helm uninstall monitoring -n monitoring || true
            # Attempt to delete the namespace (ignore if it contains other resources or is already gone)
            kubectl delete namespace monitoring --ignore-not-found=true || true
          else
            echo "Monitoring stack not found; skipping."
          fi

      - name: Compose Slack Message
        id: compose
        if: always()
        run: |
          if [ "${{ steps.check-deployment.outcome }}" = "success" ] && [ "${{ steps.inspect-deployment.outputs.deployment_status }}" = "in_progress" ]; then
            echo 'msg=:information_source: TPC-H Benchmark skipped â€” existing deployment found' >> "$GITHUB_OUTPUT"
          else
            echo 'msg=TPC-H Benchmark (Scale Factor: ${{ env.SCALE_FACTOR }}) started' >> "$GITHUB_OUTPUT"
          fi

      - name: Post Slack Notification
        uses: ravsamhq/notify-slack-action@be814b201e233b2dc673608aa46e5447c8ab13f2 # v2
        if: always()
        with:
          status: ${{ job.status }}
          notification_title: "*TPC-H Benchmark*"
          message_format: "${{ steps.compose.outputs.msg }}"
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.BENCHMARK_SLACK_WEBHOOK_URL }}
